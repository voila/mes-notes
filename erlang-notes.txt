Integers

2#1010  (base 2)
16#EA   (base 16)

-----------------------------
Characters

$Character returns the ASCII value of Character. 
$a represents the integer 97

-----------------------------
Floats

1.234E-10.

-----------------------------
The Shell
.[Return]  to evaluate
q().       to quit         

-----------------------------
Maths

/   floating point division
div integer division
rem integer remainder

−2 + 3 / 3 => 1.0

-----------------------------
Atoms

Atoms start with a lowercase letter or are delimited by single quotes. Letters, digits,
the “at” symbol (@), the full stop (.), and underscores (_) are valid characters if the
atom starts with a lowercase letter. Any character code is allowed within an atom if the
atom is encapsulated by single quotes. 

Examples of atoms starting with a lowercase letter include:
january fooBar alfa21 start_with_lower_case node@ramone true false

When using quotes, examples include:
'January' 
'a space' 
'Anything inside quotes{}#@ \n\012'
'node@ramone.erlang-consulting.com'

4> less<more.
true

Reserved atoms:
after and andalso band begin bnot bor bsl bsr bxor case catch cond div end fun if let not of or orelse query receive rem try when xor

-----------------------------
Booleans

the atoms true and false are used together with Boolean operators. 

6> is_boolean(true).
true

Logical operators

and     Returns true only if both arguments are true
andalso Shortcut evaluation of and: returns false if the first argument is false, without evaluating the second
or      Returns true if either of the arguments is true
orelse  Shortcut evaluation of or: returns true if the first argument is true, without evaluating the second
xor     “Exclusive or”: returns true if one of its arguments is true and the other false
not     Unary negation operator: returns true if its argument is false, and vice versa


-----------------------------
Tuples

In a tuple, when the first element is an atom, it is called a tag. This Erlang convention
is used to represent different types of data, and will usually have a meaning in the
program that uses it. For example, in the tuple {person, 'Joe', 'Armstrong'}  the atom
person is the tag and might denote that the second field in the tuple is always the first
name of the person, while the third is the surname.

1> tuple_size({abc, {def, 123}, ghi}).
3

% elements of the tuple are indexed from 1 rather than zero.

2> element(2,{abc, {def, 123}, ghi}).  
{def,123}
3> setelement(2,{abc, {def, 123}, ghi},def).
{abc,def,ghi}

4> {1,2}<{1,3}.
true
5> {2,3}<{2,3}.
false
6> {1,2}=={2,3}.
false


-----------------------------
Lists

Characters are represented by integers, and strings (of characters) are represented by
lists of integers. The integer representation of a character is given by preceding the
character with the $ symbol:

20>[$H,$e,$l,$l,$o,$ ,$W,$o,$r,$l,$d]
"Hello World"
21> [72,101,108,108,111,32,87,111,114,108,100].
"Hello World"

a difference between atoms and strings is efficiency. Representation of a string
takes up space proportional to the string’s size, whereas atoms are represented in a
system table and take a couple of bytes to reference regardless of their size. 

these are all equivalents:
[one, two, three, four]
[one, two, three, four|[]]
[one, two|[three, four]]
[one, two|[three|[four|[]]]]
[one|[two|[three|[four|[]]]]]

1> lists:max([1,2,3]).
2> lists:reverse([1,2,3]).
3> lists:sort([2,1,3]).
4> lists:split(2,[3,4,10,7,9]).
{[3,4],[10,7,9]}
5> lists:sum([3,4,10,7,9]).
6> lists:zip([1,2,3],[5,6,7]).
[{1,5},{2,6},{3,7}]
7> lists:delete(2,[1,2,3,2,4,2]).
[1,3,2,4,2]
8> lists:last([1,2,3]).
9> lists:member(5,[1,24]).
11> lists:nth(2,[3,4,10,7,9]).
12> lists:length([1,2,3]).
** exception error: undefined function lists:length/1
13> length([1,2,3]).

4> [1,2,3] ++ [4,5,6].  % also lists:append("r","e").
[1,2,3,4,5,6]
5> [1,2,2,3,4,4] -- [2,4].
[1,2,3,4]

When the ++ notation was added to the language, programmers went from using the
append function to abusing the ++ operator. The ++ operator and the append function
are expensive operations, as the list on the lefthand side of the expression has to be
traversed. Not only are they expensive operations, but often they are redundant, as all
I/O functions (including socket operations) in Erlang accept nonflat strings such as
["Hello ",["Concurrent "]|"World"]. ( iolists )

30> "Hello " "Concurrent " "World".
"Hello Concurrent World"


-----------------------------
Term comparison

The result of the expression is one of the Boolean atoms true or false. The
equal (==) and not equal (/=) operators compare the values on either side of the operator
without paying attention to the data types. 

Operators exactly equal (=:=) and exactly not equal (=/=) compare not only the values on either side of the equation, but also their data types.

If the expressions being compared are of different types, the following hierarchy is taken
into consideration:
number < atom < reference < fun < port < pid < tuple < list < binary

Lists are ordered lexicographically

5> [boo,hoo]<[adder,zebra,bee].
false
6> [boo,hoo]<[boo,hoo,adder,zebra,bee].
true

On the other hand, when comparing tuples, the number of elements in the constructs
is compared first, followed by comparisons of the individual values themselves:

7> {boo,hoo}<{adder,zebra,bee}.
true
8> {boo,hoo}<{boo,hoo,adder,zebra,bee}.
true

The ability to compare values from different data types allows you to write generic
functions such as sort, where regardless of the heterogeneous contents of a list, the
function will always be able to sort its elements.


-----------------------------
Variables

Variables are used to store values of simple and composite data types. In Erlang, they
always start with an uppercase letter,‡ followed by upper- and lowercase letters, inte-
gers, and underscores. 

All calls with variables in Erlang are call by value: all arguments to a function call are
evaluated before the body of the function is evaluated. The concept of call by reference
does not exist, removing one way in which side effects can be caused.

Using f() forgets all variable bindings, whereas f(Variable)
will unbind a specific Variable. You can use these operations only in the shell. 


-----------------------------
Pattern Matching

Pattern matching in Erlang is used to:
• Assign values to variables
• Control the execution flow of programs
• Extract values from compound data types

5> [Head|Tail] = [1].
** exception error: no match of right hand side value [1]
6> [Head|Tail] = [1,2,3,4].
[1,2,3,4]
7> [Head1|Tail1] = [1].
[1]
8> Tail1.
[]

What goes wrong in command 5? It looks as though this should succeed, but the var-
iables Head and Tail are bound already, so this pattern match becomes a test of whether
the expression is in fact [1,2,3,4]; you can see in command 6 that this would succeed.

We mentioned earlier that variables can start with an underscore; these denote “don’t
care” variables, which are placeholders for values the program does not need. “Don’t
care” variables behave just like normal variables—their values can be inspected, used,
and compared. 
The underscore on its own is also a “don’t care” variable, but its contents cannot be accessed: its values are ignored and never bound.


-----------------------------
Functions

When defining a function, it is a good
practice to make sure that for every argument there is one clause that succeeds; this is
* In the case of the triangle, the area is calculated using Heron’s formula where math:sqrt/1 is used to give the
square root of a float.
 often done by making the final clause a catch-all clause that matches all (remaining)
cases.


-----------------------------
Modules

Functions are grouped together in modules.
Modules are named using the –module(Name) directive.

A module example

-module(demo).
-export([double/1]).

% This is a comment.
% Everything on a line after % is ignored.

double(Value) -> times(Value, 2).
times(X,Y) -> X*Y.

The export directive contains a list of exported functions of the format
Function/Arity. These functions are global, meaning they can be called from outside
the module. 

Global calls, also called fully qualified function calls, are made by prefixing the module
name to the function. So, calling demo:double(2) would return 4. Local functions can be called only from within the module.

Functions in Erlang are uniquely identified by their name, their arity, and the module
in which they are defined. Two functions in the same module might have the same
name but a different arity. If so, they are different functions and are considered unre-
lated. There is no need to declare functions before they are called, as long as they are
defined in the module.


-----------------------------
Compiling

Once in the directory, you compile the code using c(Module) in the Erlang shell, omitting the erl suffix from the module name.

A useful directive when programming is the –compile(export_all) directive, which at
compile time will export all functions defined in the module. Another way of doing this
is to specify an option on compiling the file:
c(Mod,[export_all]).

All attributes and other module information can be retrieved by calling
Mod:module_info/0 or selectively calling the Mod:module_info/1 function. From the shell,
you can use the m(Module) command:

5> demo:module_info().
[{exports,[{double,1},{module_info,0},{module_info,1}]},
{imports,[]},
{attributes,[{vsn,[74024422977681734035664295266840124102]}]},
{compile,[{options,[]},
{version,"4.5.1"},
{time,{2008,2,25,18,0,28}},
{source,"/home/francesco/examples/demo.erl"}]}]

6> m(demo).
Module demo compiled: Date: February 25 2008, Time: 18.01
Compiler options: []
Object file: /home/francesco/examples/demo.beam
Exports:
double/1
module_info/0
module_info/1
ok


-----------------------------
Case Construct

case conditional-expression of
  Pattern1 -> expression1, expression2, .. ;,
  Pattern2 -> expression1, expression2, .. ;
  ... ;
  Patternn -> expression1, expression2, ..
end

case lists:member(foo, List) of
  true -> ok;
  false -> {error, unknown_element}
end


-----------------------------
If Construct

if
  Guard1 -> expression11, expression12, .. ;
  Guard2 -> expression21, expression22, .. ;
  ... ;
  Guardn -> expressionn1, expressionn2, ..
end

if
  X < 1 -> smaller;
  X > 1 -> greater;
  X == 1 -> equal
end

If none of the guards evaluates to the atom true, a runtime error is generated. To get a
catch-all clause, you can allow the last clause to have the atom true as the guard;

The guard expressions are a subset of the Erlang Boolean expressions that can only
contain calls to a restricted set of functions together with comparisons and arithmetic
operations.

The individual guard expressions can be built using the following constructs:
• Bound variables
• Literal Erlang terms denoting data values including numbers, atoms, tuples, lists,
and so forth
• Type tests, such as is_binary, is_atom, is_boolean, is_tuple, and so on
• Term comparisons using ==, =/=, <, >, and so on, as listed in Chapter 2
• Arithmetic expressions built using the arithmetical operators given in Chapter 2
• Boolean expressions as described in Chapter 2
• Guard built-in functions

Erlang allows simple logical combinations of guards to be written in a different way:
• Separating individual guard expressions with a comma (,) gives their conjunction,
so that such a sequence evaluates to true only if all expressions in the sequence
evaluate to true.
• Separating individual expressions (or indeed, comma-separated conjunctions)
with a semicolon ( ;) gives their disjunction, where the sequence evaluates to true
if any expression evaluates to true.


-----------------------------
Built-in Functions
-----------------------------
Object Access and Examination

hd/1
  Returns the first element of a list
tl/1
  Returns the remaining elements when the first element has been removed
length/1
  Returns the length of a list
tuple_size/1
  Returns the number of elements in a tuple
element/2
  Returns the nth element of a tuple
setelement/3
  Replaces an element in a tuple, returning the new tuple
erlang:append_element/2
  Adds an element to the tuple, as the final element

-----------------------------
Type Conversion

atom_to_list/1, list_to_atom/1, list_to_existing_atom/1
  All convert atoms to strings and back. If the atom was not previously used by
  the runtime system in the current session, calling the function
  list_to_existing_atom/1 will fail.
list_to_tuple/1, tuple_to_list/1
  Both convert between the two data types.
float/1, list_to_float/1
  Both create a float, one with an integer parameter and the other from a string.
float_to_list/1, integer_to_list/1
  Both return strings.
round/1, trunc/1, list_to_integer/1
  All return integers.

-----------------------------
Process Dictionary

There is a set of BIFs that allow functions to store values associated with a key and later
retrieve them in other parts of the program; this set of BIFs is called the process dic-
tionary. The retrieval and manipulation of these values unfortunately introduces global
variables into Erlang

-----------------------------
Meta Programming

One often refers to the ability of a function to determine what other function to call at
runtime as meta programming, that is, programs that create other programs and run
them. For this use, we have the apply/3 function that takes three arguments, namely a
module name, an exported function name, and a list of arguments. When called, it
executes the named function on the specified arguments and returns its result.

1> Module = examples.
examples
2> Function = even.
even
3> Arguments = [10].
[10]
4> apply(Module, Function, Arguments).
true

If the number of arguments is known at compile time, you can use the following no-
tation (if there are two arguments): Mod:Fun(Arg1, Arg2)
instead of the more general apply(Mod,Fun,[Arg1,Arg2]). 

-----------------------------
Process, Port, Distribution, and System Information

The date/0 function returns the current date as a tuple of {Year, Month, Day}, and the
time/0 function returns the current time as a tuple of {Hour, Minute, Second}. The
now/0 function returns a tuple of {MegaSeconds, Seconds, MicroSeconds} that have
passed since midnight, January 1, 1970.

The now/1 BIF will always return a unique value
in a particular Erlang node, even if called more than once in the same microsecond. As
a result, it can be used as a unique identifier.

-----------------------------
Input and Output

The io module provides input and output from an Erlang program. 
Each function can take a file handle (of type io_device()) as an additional (first) argu-
ment: file operations are defined in the file module.

To read a line from standard input, use io:get_line/1, which takes a prompt string (or
atom) as its input:

1> io:get_line("gissa line>").
gissa line>lkdsjfljasdkjflkajsdf.
"lkdsjfljasdkjflkajsdf.\n"

It is also possible to read a specified number of characters:

2> io:get_chars("tell me> ",2).
tell me> er
"er"

The most useful input function is io:read/1, which reads an Erlang term (i.e. a fully evaluated value) from standard input:

3> io:read("ok, then>>").
ok, then>>atom.
{ok,atom}
4> io:read("ok, then>>").
ok, then>>{2,tue,{mon,"weds"}}.
{ok,{2,tue,{mon,"weds"}}}
5> io:read("ok, then>>").
ok, then>>2+3.
{error,{1,erl_parse,"bad term"}}

Output in Erlang is provided by io:write/1, which will print an Erlang term, but the
function most commonly used is io:format/2, which provides formatted output.

io:format takes the following:
• A formatting string (or binary) that controls the formatting of the arguments
• A list of values to be printed

The formatting string contains characters that are printed as they are with control se-
quences for formatting.
Control sequences begin with a tilde (~), and the simplest form is a single character,
indicating the following:
~c
  An ASCII code to be printed as a character.
~f
  A float to be printed with six decimal places.
~e
  A float to be printed in scientific notation, showing six digits in all.
~w
  Writes any term in standard syntax.
~p
  Writes data as ~w, but in “pretty printing” mode, breaking lines in appropriate
  places, indenting sensibly, and outputting lists as strings where possible.
~W, ~P
  Behave as ~w, ~p, but eliding structure at a depth of 3. These take an extra argument
  in the data list indicating the maximum depth for printing terms.
~B
  Shows an integer to base 10.


1> List = [72,101,108,108,111,32,87,111,114].
"Hello Wor"
2> io:format("~p~n",[List]).
"Hello Wor"
ok
3> io:format("~w~n",[List]).
[72,101,108,108,111,32,87,111,114]
ok


-----------------------------
Runtime Errors

function_clause
  This is returned when none of the existing function patterns match in the called
  function. This error normally occurs when you have either forgotten a case in your
  case analysis or inadvertently called the function with the wrong argument:

factorial(N) when N > 0 ->
  N * factorial(N - 1);
factorial(0) -> 1.
1> test:factorial(-1).
** exception error: no function clause matching test:factorial(-1)

case_clause
  This is returned when none of the existing patterns in the case construct match.
  The most common reason for this is that you have forgotten one or more possible
  cases:

test1(N) ->
  case N of
    −1 -> false;
    1 -> true
  end.
1> test:test1(0).
** exception error: no case clause matching 0 in function test:test1/1

if_clause
  This is returned when none of the existing expressions in the if construct evaluate
  to true. As this is really a simplified case construct, the error is typically caused by
  a missing pattern:

test2(N) ->
  if
    N < 0 -> false;
    N > 0 -> true
  end.
1> test:test2(0).
** exception error: no true branch found when evaluating an if expression in function foo:test2/1

badmatch
  Errors occur in situations when pattern matching fails and there are no other al-
  ternative clauses to choose from. For the badmatch exception, it is very hard to point
  to a single cause, but one recurrent cause is when you inadvertently try to bind a
  variable that is already bound, as in the following:

1> N=45.
45
2> {N,M}={23,45}.
** exception error: no match of right hand side value {23,45}

badarg
  This is returned when a BIF is called with the wrong arguments. In the following
  example, length requires a list, but is called with an atom

1> length(helloWorld).
** exception error: bad argument in function length/1 called as length(helloWorld)

undef
  This is returned if the global function being called is not defined or exported. The
  cause of this exception is often that you have misspelled the function name, or have
  called the function without prepending the module name to the function call:

1> test:hello().
** exception error: undefined function test:hello/0

badarith
  This is returned when arithmetical operations are executed with an inappropriate
  argument, such as nonintegers or floats or trying to divide by zero:

1> 1+a.
** exception error: bad argument in an arithmetic expression in operator +/2 called as 1 + a


-----------------------------
Handling Errors

Using try ... catch

try Exprs of
  Pattern1 [when Guard1] -> ExpressionBody1;
  Pattern2 [when Guard2] -> ExpressionBody2
catch
  [Class1:]ExceptionPattern1 [when ExceptionGuardSeq1] ->
    ExceptionBody1;
  [ClassN:]ExceptionPatternN [when ExceptionGuardSeqN] ->
    ExceptionBodyN
end

Example:

X=2.
try (X=3) of  % badmatch error
  Val -> {normal, Val}
catch
  _:_ -> 43
end.



4> try (X=3) of
4> Val -> {normal, Val}
4> catch
4> error:Error -> {error,Error}
4> end.
{error,{badmatch,3}}

throw allows us to execute a nonnormal return within a try ... catch statement:

5> try (throw(non_normal_return)) of
5>   Val -> {normal, Val}
5> catch
5>   throw:Error -> {throw, Error}
5> end.
{throw,non_normal_return}

Classes of error

error
 This is the principal class of errors, and you saw the various types of runtime errors
 in the preceding section; error can also be raised by calling the BIF
 erlang:error(Term).

throw
 This is the class that is generated by an explicit call to throw an exception, which
 will be caught by an enclosing try ... catch expression. Use of throw in Erlang is
 discouraged, because it makes understanding program behavior substantially more
 difficult.

exit
 This can be raised by calling the exit/1 BIF, invoked with a reason for termination;
 exits can also be produced by an exit signal.


Using catch

The catch expression allows you to trap when runtime errors occur. The format of this
is catch expression, where if the expression evaluates correctly it returns the value of
the expression. But if a runtime error occurs, it returns the tuple {'EXIT', Error}, where
Error contains information on the runtime error.


-----------------------------
Useful Modules

array
  The array module contains an abstract data type for functional, extensible arrays.
  They can have a fixed size, or grow as needed. The module contains functionality
  to set and inspect values as well as to define recursions over them.

calendar
  The calendar module provides functions to retrieve local and universal times as
  well as providing time conversions for the day of the week, date, and time. Time
  intervals can be computed, ranging from dates down to a microsecond granularity.
  The calendar module is based on the Gregorian calendar and the now/0 BIF.

dict
  The dict module is a simple key value dictionary, which allows you to store, re-
  trieve, and delete elements, merge dictionaries, and traverse them.

erlang
  All BIFs are considered to be implemented in the erlang module. The manual page
  for this module lists all of the Erlang BIFs, differentiating between the generic ones
  and the ones that are specific to the VM, and therefore those that are auto-imported
  and those that are not.

file
  The file module provides an interface to the filesystem, allowing you to read,
  manipulate, and delete files.

filename
  The filename module allows you to write generic file manipulation and inspection
  functions that will work regardless of the file notation used by the underlying op-
  erating system.

io
  The io library module encapsulates the standard I/O server interface functions,
  allowing you to read and write strings to I/O devices, including stdout.

lists
  The lists list-manipulation module is without a doubt the most used library mod-
  ule in all major Erlang systems. It provides functions for inspecting, manipulating,
  and processing lists.

math
  All of the standard mathematical functions, including pi/0, sin/1, cos/1, and
  tan/1, are implemented in the math library module.

queue
  The queue module implements an abstract data type for FIFO queues.

random
  The random module, given a seed, provides a pseudorandom number generator.

string
  The string module contains an array of string processing functions. It differentiates
  itself from the lists module in that it takes into consideration the fact that the
  contents of the lists are ASCII characters.

timer
  The timer module contains functions that relate to time, including generation of
  events and conversion of various time formats to milliseconds, the main unit used
  by this module.


-----------------------------
The Debugger

You start the debugger by typing debugger:start() and a monitor window appears.
This window displays a list of trace-compiled modules, attached (traced) processes,
and other debug-related settings (see Figure 3-2).

To trace a module, you first need to compile it with the debug_info flag. In your Unix
shell, you do that using the following command:
erlc +debug_info Module.erl

From the Erlang shell, use either of the following two commands:
c(Module, [debug_info]).
compile:file(exception, [debug_info]).



CONCURRENCY

-----------------------------
Creating processes

Pid2 = spawn(Module, Function, Arguments).

You can use the shell command i() to find out what the currently executing processes in the runtime system are doing.
while the processes() command lists all the running processes.

-----------------------------
Message Passing

id ! Message 

where Pid is a valid process identifier and Message is avalue from any Erlang data type

-----------------------------
Receiving Messages

Messages are retrieved from the process mailbox using the receive clause. The
receive clause is a construct delimited by the reserved words receive and end, and contains a number of clauses.

receive
 Pattern1 when Guard1 -> exp11, .., exp1n;
 Pattern2 when Guard2 -> exp21, .., exp2n;
 ...
 Other -> expn1, .., expnn
end

-----------------------------
Registered Processes

It is not always practical to use pids to communicate with processes. To use a pid, a process needs to be notified of it and store its value. It is common to register processes that offer specific services with an alias, a name that can be used instead of the pid. You register a process with the register(Alias, Pid) BIF, where Alias is an atom and Pid is the process identifier. You do not have to be a parent or a child of the process to call
the register BIF; you just need to know its process identifier.

Sending messages to nonexistent registered processes causes the calling process to terminate with a badarg (see Figure 4-10). This behavior is different from sending a message to a process identifier for a nonexistent process, as registered processes are assumed to provide a service. The absence of a registered process is therefore treated as a bug. 

the shell command regs() lists the registered processes

-----------------------------
Timeouts

You saw that if a process enters a receive statement and none of the messages matches, the process will get suspended.In most cases, though, all you want to do is check the mailbox, and if nothing has arrived, continue with your household chores. Erlang processes can do just
that by using the receive ... after construct:

receive
  Pattern1 when Guard1 -> exp11, .., exp1n;
  Pattern2 when Guard2 -> exp21, .., exp2n;
  ...
  Other -> expn1, .., expnn
after
  Timeout -> exp1, .., expn
end



When a process reaches the receive statement and no messages pattern-match, it will wait for Timeout milliseconds. If after Timeout milliseconds no message has arrived, the expressions in the body of the after clause are executed. Timeout is an integer denoting the time in milliseconds, or the atom infinity. Using infinity as a timeout value is the same as not including the after construct.



Process Designs Patterns

----------------------------------


Process Error Handling

----------------------------------


Records and Macros

----------------------------------

----------------------------------
Records
----------------------------------

-record(person, {name, age, phone}).      % introduce a record type 'person'
-record(person, {name, age=0, phone=""}). % with default values

#person{name="joe", age=21, phone="999-999"}

P = #person{name="Fred"}
P#person.age                    % access    
NewPerson = P#person{age=37}    % modify

-----------------------------------
Pattern matching over records

birthday(#person{age=Age} = P) ->
   P#person{age=Age+1}.

------------------------------------
Records in the shell

rr(moduleName).           % list all records definitions in moduleName
rd(name, {field1, ...}).  % defines a record in the shell
rl().                     % list all record definition visible in the shell
rf(RecordName), rf()      % forget one or all record definitions in the shell


c(Module,['E']). % compiles the records in Module to Module.E

----------------------------------
Macros
----------------------------------
-define(TIMEOUT, 1000).

receive 
  after ?TIMEOUT -> ok 
end


-ifdef(debug).
 -define(DBG(Str, Args), io:format(Str, Args)).
-else.
 -define(DBG(Str, Args), ok).
-endif.

c(Module,[{d,debug}]). % set the flag debug
c(Module,[{u,debug}]). % unset the flag debug

or compile:file(Module,[{d,debug}]).

c(Module,['P']). % applies epp to a file (macro-expand)


Include Files
------------------------------------
it is customary to put record and macros in a separate file to make
the definitions available to more than one module.

-include("File.hrl").

by default the compiler first looks for include in the current
directory, and the directory of the script being compiled.

c(Module, [{i, Dir}]). % adds a path to the include paths list



------------------------------------
Software Upgrade


fully-qualified function calls, will switch to updated (current) module, whereas
non qualified calls will refer to old module (old and current refer to the order the
modules were loaded in the runtime system).

Code is loaded:
  - by calling a function in a module not-yet loaded
  - when compiling a module, compile:file(Module) or c(Module) in the shell
  - code:load_file(Module) or l(Module) in the shell
  
To see if a module is loaded:
  - try auto-completion (tabbing) in the shell
  - code:is_loaded(Module) returns locationof beam file or false


The Code Server
-------------------------------------

It searches sequentially a list of directories (the code search path), starting with 
the current work directory, for the compiled version of the module to load in the virtual machine.

code:get_path(). %% view the default search paths

Default directories will include all the library applications which comes as part of Erlang/OTP
(in $ERLANGROOT/lib directory)

code:root_dir() %% find out the Erlang root directory.

You can add directories to the code search path by using:

code:add_patha(Dir) % at the begining of the list
or erl -pa Path (when starting the shell)

code:add_pathz(Dir) % at the end of the list
or erl -pz Path


Shell Modes
---------------------------------------
erl -mode Mode %% Mode is either embedded or interactive (default)

in interactive mode, only the runtime systems modules are loaded, other modules
are dynamically loaded when a fully qualified function is called

in embedded mode, all the modules listed in a binary boot file are loaded. 
Calls to unloaded modules are runtime errors.


Purging
---------------------------------------
code:purge(Module)  %% related processes are terminated, then module is removed

code:soft_purge(Module) %% only remove the old module if no related processes are running









Binaries
----------------------
Defaults

The default type for a segment is integer. The default type does not depend on the value, even if the value is a literal. For instance, the default type in '<<3.14>>' is integer, not float.

The default Size depends on the type. For integer it is 8. For float it is 64. For binary it is all of the binary. In matching, this default value is only valid for the very last element. All other binary elements in matching must have a size specification.

The default unit depends on the the type. For integer and float it is 1. For binary it is 8.

The default signedness is unsigned.

The default endianness is big.

3> <<X:2, _:2>> = <<5:4>>.
<<5:4>>
4> X.
1
5> <<X:2/bitstring, _:2>> = <<5:4>>.
** exception error: no match of right hand side value <<5:4>>
6> f().
ok
7> <<X:2/bitstring, _:2>> = <<5:4>>.







----------------------------------------------
ETS tables


Creating tables
---------------
TabId = ets:new(TableName, [named_table, Sort, {keypos, Pos}, AccessControl])

named_table: TableName can be used to access the table (otherwise use TabId)
Sort: set (default), ordered_set, bag, duplicate_bag
AccessControl: private, protected (default), public
Pos: index of the table key in the rows (default: 1)

ets:delete(TabId)           % tables are not GCed (the owner process can delete it or transfer ownership)

ets:info(TabId | TableName) % returns the attribute of the given table


Handling table elements
-----------------------
true = ets:insert(TabId, {alison, sweden})
true = ets:insert(TabId, {alison, italy})  % insertion will overwrite old entry
[{alison, italy}] = ets:lookup(TabId, alison)


Traversing tables
-----------------
ets:first(TabId)     % return first key in table
ets:next(TabId, Key) % return key after Key, returns '$end_of_table' when the table is completely traversed.

ets:last(TabId) % returns last element in an ordered_set table (otherwise, the first element)

Concurrent updates
------------------
If other processes execute destructive calls to ETS table while it is traversed with ets:first/1 and ets:next/2
use ets:safe_fixtable(TabRef, true) (guarantees that during traversal an element is only once -- does not guarantees that all elements will be accessed however). Do not forget to release the table after fixing it, otherwise deleted elements won't be removed.


Querying with match
-------------------
for example:

ets:new(countries, [bag, named_table]).
ets:insert(countries, {yves, france, cook}).
ets:insert(countries, {manu, france, bartender}).
ets:insert(countries, {joe, england, doctor}).
ets:insert(countries, {marco, italy, cook}).

ets:match(countries, {'$1',france, '_'}). % '_' wildcard match, '$0' or '$1' variable bindings 
=> [[yves],[manu]]
ets:match(countries, {'$1','$0', cook}).
=> [[italy,marco],[france,yves]]
ets:match(countries, {'$0','$1', cook}).
=> [[marco,italy],[yves,france]]

ets:match_object(countries, {'_',france, '_'}). % return the entire tuples
=>[{manu,france,bartender},{yves,france,cook}]

ets:match_delete(countries, {'_',france, '_'}). % delete the matching objects
=> true
ets:match_object(countries, {'_',france, '_'}).
=> []

NOTE: match operations are implementeds as BIFs (and as such are executed atomically), they can therefore stop
other processes from executing until the operation has traversed the whole table and disrupt the real-time properties
of your system (it's best to use first/1 and next/2 in that case).


Querying with select
--------------------
a match specification is an Erlang Term that describes a small program

example:
ets:select(countries,
	[{{'$1','$2','$3'},       % binding pattern
	  [{'/=','$3',cook}],     % list of guard expressions in prefix form
          [['$2','$1']]}]).       % the return expression
=> [[france,manu],[england,joe]]


ets:fun2ms/1 takes a fun as an argument describing the match we want to execute on the table together
with the return values we want

MS = ets:fun2ms(fun({Name, Country, Job}) when Job /= cook -> [Country, Name] end).
=> [{{'$1','$2','$3'},[{'/=','$3',cook}],[['$2','$1']]}]
ets:select(countries, MS).
=> [[france,manu],[england,joe]]


Other operations
--------------------
ets:tab2file(TableId | TableName, FileName) % dumps table into a file
ets:file2tab(FileName)                      % reads a dumped table back in -> {ok, Tab} | {error, Reason}
ets:tab2list(TableId | TableName)           % returns a list of the elements
ets:i()                                     % info about all the ETS tables seen by the current process


Records and ETS tables
----------------------
The default key position in ETS is the first element of the tuple.
In records that position is reserved for the record type, so you need to explicitely state the key position


rd(rec, {name, country, job}).
ets:new(countries, [named_table, {keypos, #rec.name}]).
ets:insert(countries, #rec{name=manu, country=france, job=bartender}).
ets:lookup(countries, manu).
=> [#rec{name = manu,country = france,job = bartender}]
ets:match(countries, #rec{name='$1',country='$2',_='_'}).
=>[[manu,france]]
ets:match_object(countries, #rec{country=france,_='_'}). 
=> [#rec{name = manu,country = france,job = bartender}]
MS = ets:fun2ms(fun(#rec{name=N, country=C}) when C == france -> N end). 
ets:select(countries, MS).                                              
=> [manu]


Visualizing tables
-------------------
Tables owned by the current node and connected nodes can be shown through the visualizer tool
launched by calling tv:start().



----------------------------------------------
DETS tables


Dets tables provide efficient file-based Erlang term storage.
The size of Dets files cannot exceed 2 GB.

Creating tables
---------------
dets:open_file(TableName, Options)

Options:
  {auto_save, Interval}   % in millisec, default is 3 minutes
  {file, FileName}        % override default naming and location to save dets file
  {repair, Bool}          % whether the table should be automatically repaired (if not properly closed)
  {type, TableType}       % set (default), bag, duplicate_bag
  {max_no_slots, Number}  % default 2,000,000; max 32,000,000.
  {min_no_slots, Number}  % default 256
  {ram_file, Bool}         % if need to populate the table with a lots of elts, then dets:sync(Name)

example: 

dets:open_file(food, [{type, bag}, {file, "/tmp/food"}]).
dets:insert(food, {sweden, meatballs}).
dets:lookup(food, sweden)
dets:close(food).

----------------------------------------------
Distributed Programming



manu@chleb:~$ erl -sname foo

(foo@chleb)1>                                        % foo@chleb is the identifier of the node

(foo@chleb)2> c(dist).
{ok,dist}
(foo@chleb)3> spawn('bar@chleb', dist, t, [self()]). % spawn dist:t() on node 'bar@chleb'
<5922.44.0>

if the process is named, messaging syntax is : {<name>, <node>} ! msg
 

erlang:is_alive()  % is the node alive
net_kernel:start([<name>,...])
ner_kernel:stop()

erl -sname <name> % short name (on local network)
erl -name <name>  % long name

nodes with long names can only communicate with other nodes with long names (similarly for short names)

Communication and Security
----------------------------------
Two nodes wishing to communicate need to share the same cookie

erl -sname foo -setcookie blah        % start node 'foo' with cookie 'blah'


net_adm:ping(<node_name>).
erlang:set_cookie(<node_name>, <cookie>).








-----------------------------------
OTP Behaviours

gen_server behaviour
*********************

starting the server (these are synchronous):
----------------------------------------------
start(Module, Args, Options) 
start_link(Module, Args, Options)
start(Name, Module, Args, Options)      
start_link(Name, Module, Args, Options)

CallbackModule must have a function init(Args) -> {ok, LoopData}
start_link() is similar but links to its parent (as behaviour should in OTP)

passing messages
-----------------
call(Name, Message): 
  synchronous function causing handle_call() to be called
  -> {reply, Reply, NewLoopData} | {stop, Reason, Reply, NewLoopData} 

cast(Name, Message): 
  asynchronous function causing handl_cast() to be called
  -> {noreply, NewLoopData} | {stop, Reason, NewLoopData}

upon receiving message the server process calls handle_call() / handle_cast()
ServerName is the local registered name of the server, its Pid or the tuple {global, Name}
If the process calling the server gets no response withing 5 sec, it terminates.
The timeout can be overidden with gen_server:call(ServerName, Message, Timeout)


Non OTP-compliant messages
--------------------------
handle_info(Msg, LoopData) -> {noreply, NewLoopData} | {stop, Reason, NewLoopData}


Termination
-----------
terminate(Reason, LoopData) -> ()
called when handle_xxx return {stop, ...}, a good place to clean the LoopData of the server
(for instance closing ets and dets tables)



Supervisor behaviour
*********************

Starting
========
start_link(Name, Module, Args)
start(Name, Module, Args)
start_link(Module, Args)
start(Module, Args)

Name: registered name for the supervisor: {local, Name} or {global, Name}
Module: name of the module where init/1 is placed
Args: term passed to init/1 when it is called

init/1 return a tuple: {ok, SupervisorSpecification, ChildSpecificationList}}

SupervisorSpecification 
-----------------------
A tuple that specifies how to handle process crashes and restarts

{RestartStrategy, AllowedRestarts, MaxSeconds}

RestartStrategy can be:
  one_for_one: restart only the child that has terminated
  one_for_all: terminate all the children and restart them
  rest_for_one: terminate all the children started after the child that crashed and restart them

AllowedRestarts
  limit the number of abnormal terminations the supervisor is allowed to handle in MaxSeconds
  Beyond this limit, the supervisor terminates.

ChildSpecificationList 
-----------------------
Specifies which children to start and monitor, how to terminate and restart them.
Usually hard coded in the supervisor callback module.

Each child specification is:
{Id, {Module, Function, Arguments}, Restart, Shutdown, Type, ModuleList}

Id: 
unique identifier (not a Pid) for a particular child within a supervisor

{Module, Function, Arguments}: 
used by the supervisor to start the child

Restart can be: 
  transient: never restarted
  temporary: restarted only on abnormal termination
  permanent: always restarted

ShutDown:
  specify how many millisecs a behaviour trapping exits is allowed to execute in its terminate() callback
  after receiving the shutdown signal from its supervisor (because of AllowedRestarts or RestartStrategy).
  Beyond that time the process is killed unconditionally. Values can also be: infinity (for a supervisor process)
  or brutal_kill for unconditional termination).

Type can be:
  worker | supervisor

ModuleList:
  list of modules implementing the process
  used to determine which processes should be suspended during a software upgrading (usually include the
  behavior callback module).
  

The function supervisor:check_childpecs/1 verify the syntax/semantics of a ChildSpecificationList 

Dynamic Children
================

for a supervisor to create a child dynamically use:

start_child(SupName, ChildSpec)
terminate_child(SupName, Id)
restart_child(SupName, Id)
delete_child(SupName, Id)  (the ChildSpec is permanently removed from supervisor)

SupName is the registered name of the supervisor or its Pid
ChildSpec a single child specification tuple as described previously
Id the unique child identifier defined in ChildSpec




OTP Applications
*****************

A resource file associated with an application describe and specify its modules, registered processes, configuration data.

application:which_applications() % list currently running apps

Directory structure
===================
code:get_path() % each code path points to a specially structured directory of an OTP app

src:
  source code of all the modules in the application

ebin:
  all compiled beam files and the application resource file

include:
  all header files (hrl) intended for use outside the application
  -include_lib("App/include/Name.hrl")

priv:
  non Erlang related resources
  can be accessed with code:priv_dir(App)


Application resource file
=========================

Starting and stopping applications
==================================
application:start(Appname)
application:stop(Appname)


Releases
*****************
systools:make_rel(Name, Options)
  inspect/check the .app files listed in the .rel file.
  Name.boot and Name.script files are produced

Name.boot: a binary file that loads application modules and starts top level supervisors.
Name.script: text version of .boot file





-----------------------------------
Mnesia



-----------------------------------
Socket Programming



-----------------------------------
Interfacing / Interoperability



-----------------------------------
Trace BIFs


Trace events are received as mailbox messages of the form

 {trace, Pid, Tag, Data1 [, Data2]}

Only one process may receive trace events
The tracer process is usually the process that called erlang:trace() (unless it redirected them to another process) 
The tracer process cannot be traced.

erlang:trace(PidSpec, Bool, TraceFlags)

PidSpec defines the processes to be traced:
  existing: all processes up to the call to trace()
  new     : all processes spawned after the call to trace()
  all     : all processes before and after the trace() call


Bool: indicates if we want to enable or disable certain aspects of the tracing

Process Trace Flags
-------------------
send         trace messages sent by a process : {trace, Pid, send, Message, To}
'receive'    trace messages received by a process : {trace, Pid, 'receive', Msg}
running      trace when process is preempted or scheduled : {trace, Pid, in|out, {M, F, Arity}}
procs        trace the following process-related events:
                {trace, Pid, spawn, Pid2, {M, F, Args}}
                {trace, Pid, exit, Reason}
                {trace, Pid, link | unlink, Pid2}
                {trace, Pid, getting_linked | getting_unlinked, Pid2}
                {trace, Pid, register | unregister, Pid2}

Inheritance flags
-----------------
set_on_spawn : any process spawned by the process will inherit all the PT flags including set_on_spawn
set_on_first_spawn: any process spawned by the process will inherit all the PT flags except set_on_spawn

Garbage collection
------------------
garbage_collection   trace events related to GC: {trace, Pid, gc_start|gc_end, Info}

Info is a list of tagged tuples containing (all sizes are in words):
  heap_size:           used part of the current heap
  heap_block_size:     size of the memory block that stores heap and stack
  old_heap_size:       used part of the old heap
  old_heap_block_size: size of the memory block that stores the old heap
  stack_size:          actual stack size
  recent_size:         size of the data that survived the previous GC
  mbuf_size:           mailbox size

timestamp            to have accurate records of when a trace event is generated, format is
                     {MegaSeconds, Seconds, MicroSeconds}

cpu_timestamp        Pid must be: all

Tracing calls with the trace_pattern BIF
----------------------------------------
Enable tracing of local and global function calls
Must be used in conjonction with erlang:trace(PidSpec, Bool,[call, return_to])
  trace defines the process to monitor
  trace_pattern defines the subset of functions to trace

It generates messages of the form:
  {trace, Pid, call, {M, F, Args}}       when function F in module M is called
  {trace, Pid, return_to, {M, F, Args}}  when execution of function F is completed (base case for rec functions !)

the arity flags turns {M, F, Args} to {M, F, Arity} (useful to reduce the size of messages)

erlang:trace_pattern(MFA, Condition, FlagList)

MFA can be {Module, Function, Arity}, {Module, Function, '_'}, {Module, '_', '_'}, {'_', '_', '_'}
(modules must be loaded before trace_pattern is called)

Condition: can be true (all functions in MFA) false (none) or a match specification

FlagList: defines the the type of traced function, global (only exported), local (both exported and nonexported)
The dbg Tracer
---------------

